#!/usr/bin/env python3
"""
INCAR Core Module - Self-contained INCAR generation utilities
Consolidated from brain.incar and brain.data modules
"""

import os
import sys
from difflib import SequenceMatcher

# ============================================================================
# Part 0: DFT+U, Spin, and other elemental parameters
# ============================================================================

### DFT + U parameters
u_value = {
    'Ag': 5.0, 'Cu': 5.0, 'Fe': 5.0, 'Ir': 5.0, 'Ni': 5.0, 'Pd': 5.0,
    'Pt': 5.0, 'Rh': 5.0, 'Co': 5.0, 'Ru': 5.0, 'Os': 5.0, 'Au': 5.0,
    'Ti': 5.1, 'Zn': 5.0, 'Sn': 5.0
}

j_value = {
    'Ag': 1.0, 'Cu': 1.0, 'Fe': 1.0, 'Ir': 1.0, 'Ni': 1.0, 'Pd': 1.0,
    'Pt': 1.0, 'Rh': 1.0, 'Co': 1.0, 'Ru': 1.0, 'Os': 1.0, 'Au': 1.0,
    'Ti': 1.0, 'Zn': 1.0, 'Sn': 1.0
}

### SPIN & Magnetic moments
mag_value = { 
    'Ag': 0.0, 'Cu': 1.0, 'Fe': 3.0, 'Ir': 0.0, 'Ni': 1.0, 'Pd': 0.0,
    'Pt': 0.0, 'Rh': 0.0, 'Co': 2.0, 'Ru': 0.0, 'Os': 0.0, 'Au': 0.0,
    'Ti': 0.0, 'Zn': 0.0, 'Sn': 0.0, 'O': 0.0
}

# ============================================================================
# Part 1: Standard INCAR parameters
# ============================================================================

standard_incar = {
    'd_system': {'SYSTEM': 'Generated By Q_robot'},
    'd_start': {'PREC': 'A', 'ISTART': '0', 'ICHARG': '2', 'GGA': 'PE'},
    'd_elec': {'ISPIN': '1', 'ENCUT': '450', 'NELM': '100', 'EDIFF': '1E-05', 'LREAL': 'AUTO', 'ALGO': 'F'},
    'd_ionic': {'EDIFFG': '-0.03', 'NSW': '500', 'IBRION': '2', 'POTIM': '0.10', 'ISIF': '2', 'ISYM': '2'},
    'd_ismear': {'ISMEAR': '0', 'SIGMA': '0.10'},
    'd_write': {'LWAVE': 'F', 'LCHARG': 'F', 'LVHAR': 'F', 'LORBIT': '11', 'NWRITE': '0'},
    'd_lapack': {'LSCALAPACK': 'F'},
    'd_ncore': {'NCORE': '8'}
}

# ============================================================================
# Part 2: Task-specific INCAR parameters
# ============================================================================

tasks_incar = {
    'd_cal_single': {'NSW': '0'},
    'd_cal_dos': {'ISMEAR': '0', 'SIGMA': '0.05', 'NEDOS': '1000'},
    'd_cal_electronic': {'LAECHG': 'T', 'LCHARG': 'T', 'LELF': 'T', 'LWAVE': 'T', 'LORBIT': '11', 'NEDOS': '1000'},
    'd_cal_workfunction': {'LVHAR': 'T', 'LDIPOL': 'T', 'IDIPOL': '3'},
    'd_cal_md': {'IBRION': '0', 'TEBEG': '273', 'TEEND': '273', 'MDALGO': '2', 'SMASS': '0', 'NBLOCK': '5', 'POTIM': '1', 'NSW': '50000'},
    'd_cal_gas': {'ISMEAR': '0', 'SIGMA': '0.01'},
    'd_cal_bulk': {'ISIF': '3', 'ENCUT': '700', 'LDIPOL': 'F'},
    'd_cal_dftu': {'LDAU': 'T', 'LDAUTYPE': '2', 'LASPH': 'T', 'LDAUPRINT': '0', 'LMAXMIX': '4'},
    'd_cal_dipole': {'LDIPOL': 'T', 'IDIPOL': '3'},
    'd_cal_tsopt': {'IBRION': '1', 'POTIM': '0.05'},
    'd_cal_neb': {'LSCALAPACK': 'F', 'LTANGENTOLD': 'F', 'LCLIMB': 'T', 'SPRING': '-10', 'IBRION': '1', 'EDIFFG': '-0.03', 'POTIM': '0.15'},
    'd_cal_dimer': {'IBRION': '44', 'EDIFFG': '-0.03', 'POTIM': '0.10', 'FINDIFF': '2', 'DIMER_DIST': '0.01', 'MINROT': '0.0087266', 'STEP_SIZE': '0.01', 'STEP_MAX': '0.10', 'NSW': '500'},
    'd_cal_freq': {'PREC': 'A', 'IBRION': '5', 'POTIM': '0.015', 'NFREE': '2', 'EDIFF': '1E-7', 'NWRITE': '3'},
    'd_cal_vdwD3zero': {'IVDW': '11'},
    'd_cal_vdwD3bj': {'IVDW': '12'},
    'd_cal_mltrain': {'ML_LMLFF': 'T', 'ML_MODE': 'train', 'ML_MB': '4000', 'ML_IERR': '1', 'ML_OUTPUT_MODE': '1', 'ML_ICRITERI': '0', 'ML_CTIFOR': '0.02', 'ML_SCLC_CTIFOR': '0.5'},
    'd_cal_mlselect': {'ML_LMLFF': 'T', 'ML_MODE': 'select', 'ML_MCONF_NEW': '10', 'ML_MB': '4000', 'ML_IERR': '1', 'ML_OUTPUT_MODE': '1', 'ML_ICRITERIA': '3', 'ML_CTIFOR': '0.002', 'ML_CDOUB': '4'},
    'd_cal_mlrefit': {'ML_LMLFF': 'T', 'ML_MODE': 'refit', 'ML_RCUT1': '10', 'ML_RCUT2': '6.0', 'ML_W1': '0.1', 'ML_MRB1': '15', 'ML_MRB2': '10', 'ML_SION1': '0.5', 'ML_LMAX2': '3', 'ML_SIGW0': '1', 'ML_EPS_LO': '1E-11', 'ML_LSPARSDES': 'F'},
    'd_cal_mlmd': {'ML_MODE': 'run', 'ML_OUTBLOCK': '50', 'ML_OUTPUT_MODE': '0', 'IBRION': '0', 'TEBEG': '300', 'TEEND': '800', 'MDALGO': '2', 'SMASS': '0', 'NBLOCK': '50', 'POTIM': '1', 'NSW': '500000'},
    'd_cal_ispin': {'ISPIN': '2'},
    'd_cal_pbe0': {'LHFCALC': 'T', 'GGA': 'PE', 'AEXX': '0.25', 'AGGAC': '1.0', 'ALDAC': '1.0'},
    'd_cal_hse03': {'LHFCALC': 'T', 'GGA': 'PE', 'AEXX': '0.25', 'HFSCREEN': '0.3', 'AGGAC': '1.0', 'ALDAC': '1.0'},
    'd_cal_hse06': {'LHFCALC': 'T', 'GGA': 'PE', 'AEXX': '0.25', 'HFSCREEN': '0.2', 'AGGAC': '1.0', 'ALDAC': '1.0'},
    'd_cal_b3lyp': {'LHFCALC': 'T', 'GGA': 'B3', 'AEXX': '0.20', 'AGGAX': '0.72', 'AGGAC': '0.81', 'ALDAC': '0.19'},
    'd_cal_hf': {'LHFCALC': 'T', 'AEXX': '1.0', 'AGGAC': '0.0', 'ALDAC': '0.0'},
}

tasks_recorded = [i.split('_')[2].lower() for i in tasks_incar.keys()]

# ============================================================================
# Part 3: Parameter update functions for special cases
# ============================================================================

def check_pos_car():
    """Check if POSCAR exists and return element list."""
    poscar_paths = ['POSCAR', './01/POSCAR']
    ele_list = []
    for path in poscar_paths:
        if os.path.isfile(path):
            try:
                from ase.io import read
                atoms = read(path, format='vasp')
                ele_list = atoms.get_chemical_symbols()
                return True, ele_list
            except ImportError:
                # ASE not available, try basic parsing
                with open(path, 'r') as f:
                    lines = f.readlines()
                    if len(lines) > 5:
                        # Line 6 contains element names
                        elements = lines[5].split()
                        # Line 7 contains counts
                        counts = list(map(int, lines[6].split()))
                        ele_list = []
                        for elem, count in zip(elements, counts):
                            ele_list.extend([elem] * count)
                        return True, ele_list
    
    print('POSCAR Not Found. Be careful about the D2, DFT+U parameters.')
    return False, []


def dftu_update(dftu):
    """Update DFT+U parameters based on POSCAR elements."""
    is_poscar_here, ele_list = check_pos_car()
    if not is_poscar_here:
        print("POSCAR not found. Skipping DFT+U parameter update.")
        return dftu

    unique_elements = []
    ldaul, u, j = [], [], []

    for element in ele_list:
        if element not in unique_elements:
            unique_elements.append(element)
            if element in u_value:
                ldaul.append(2)  # Apply DFT+U to this element
                u.append(u_value[element])
                j.append(j_value[element])
            else:
                ldaul.append(-1)  # No DFT+U applied
                u.append(0)
                j.append(0)

    # Update DFT+U parameters in the INCAR dictionary
    dftu.update({
        'LDAUL': '  '.join(map(str, ldaul)),
        'LDAUU': '  '.join(map(str, u)),
        'LDAUJ': '  '.join(map(str, j))
    })

    print(f"LDAUL set to: {ldaul}")
    print(f"LDAUU set to: {u}")
    print(f"LDAUJ set to: {j}")

    return dftu


def neb_update(neb):
    """Add the IMAGE numbers to NEB calculation."""
    folders = [f for f in os.listdir('.') if os.path.isdir(f)]
    images = len([i for i in folders if i.isdigit()]) - 2
    neb.update({'IMAGES': str(images)})
    return neb


def freq_update(freq):
    """Remove NCORE for frequency calculations."""
    if 'd_ncore' in standard_incar:
        del standard_incar['d_ncore']
    return standard_incar


def spin_update(ispin):
    """Update MAGMOM based on element magnetic moments from POSCAR."""
    try:
        from ase.io import read
        atoms = read("POSCAR")
        symbols = atoms.get_chemical_symbols()
    except:
        try:
            with open("POSCAR", 'r') as f:
                lines = f.readlines()
                if len(lines) > 5:
                    elements = lines[5].split()
                    counts = list(map(int, lines[6].split()))
                    symbols = []
                    for elem, count in zip(elements, counts):
                        symbols.extend([elem] * count)
                else:
                    print("POSCAR format not recognized. Skipping MAGMOM update.")
                    return ispin
        except FileNotFoundError:
            print("POSCAR cannot be found. Exiting.")
            return ispin

    element_counts = {}
    for symbol in symbols:
        element_counts[symbol] = element_counts.get(symbol, 0) + 1

    magmom_list = []
    for symbol, count in element_counts.items():
        magmom_per_atom = mag_value.get(symbol, 0.0)
        magmom_list.append(f"{count}*{magmom_per_atom}")

    magmom_str = "  ".join(magmom_list)
    ispin.update({'MAGMOM': magmom_str})

    print(f"MAGMOM line updated: {magmom_str}")
    return ispin


def analyze_tasks(tasks):
    """Analyze and validate requested tasks."""
    vdw_list = []
    unsupported_tasks = []

    for task in tasks:
        task_lower = task.lower()

        # Handle vdW and SCAN functional warnings
        if 'vdw' in task_lower:
            vdw_list.append(task)
        if 'scan' in task_lower:
            print("VASP 5.4.3 or higher is required for METAGGA = SCAN functional.")
            print("See: https://cms.mpi.univie.ac.at/wiki/index.php/METAGGA")

    # Check if multiple vdW types are set
    if len(vdw_list) >= 2:
        print("You cannot set more than one vdW type at the same time.")
        print(f"Detected vdW types: {' '.join(vdw_list)}")
        print("Please confirm your vdW type and rerun the command.")
        exit()

    dict_tasks = {}
    dict_task_groups = {}

    for task in tasks:
        if task in tasks_recorded:
            for k_task, v_task in tasks_incar.items():
                task_type = k_task.split('_')[2].lower()
                if task == task_type:
                    # Handle specific task updates
                    if task == 'dftu':
                        dftu_update(v_task)
                    elif task == 'neb':
                        neb_update(v_task)
                    elif task in ['vdwoptb86b', 'vdwoptb88', 'vdwdf2', 'vdwdf', 'vdwoptpbe', 'vdwrevdf2']:
                        print("Reminder: Copy vdw_kernel.bindat file to your job folder!\n" * 3)
                    elif task == 'ispin':
                        spin_update(v_task)
                        standard_incar['d_elec']['ISPIN'] = '2'
                    elif task == 'freq':
                        freq_update(v_task)
                    
                    # Update task dictionaries
                    dict_tasks.update(v_task)
                    dict_task_groups[k_task] = v_task
        else:
            unsupported_tasks.append(task)

    # Handle unsupported tasks
    if unsupported_tasks:
        print("The following tasks are not supported:\n")
        for task in unsupported_tasks:
            print(f"- {task}")
        print("\nSupported tasks:\n")
        print(" ".join(f"- {recorded_task}" for recorded_task in tasks_recorded))
        print("\nPlease use one of the supported tasks above and rerun the command.")
        exit()

    return dict_tasks, dict_task_groups


# ============================================================================
# Part 4: INCAR file generation and manipulation
# ============================================================================

def generate_incar(standard_incar, dict_tasks, dict_task_groups):
    """Create INCAR file."""
    incar_out = open('INCAR', 'w')
    for k_std, v_std in standard_incar.items():
        # Write the standard incar parameters
        incar_out.write('%s\n' % (k_std.upper().replace('D_', '#')))
        for k, v in v_std.items():
            if k not in dict_tasks.keys():
                # Write the parameters are not affected by the user's task
                incar_out.write('%s = %s \n' % (k, v))
        incar_out.write('\n')

    for k_task, v_task in dict_task_groups.items():
        # Write the specific parameters for the tasks
        incar_out.write('\n%s \n' % (k_task.upper().replace('D_', '#')))
        for k, v in v_task.items():
            incar_out.write('%s = %s \n' % (k, v))
    incar_out.close()


def incar_alter(parameter, value):
    """Change the parameter values, if the parameter is not in the INCAR, then add it."""
    if not os.path.isfile('INCAR'):
        print("INCAR file not found.")
        return

    f = open('INCAR', 'r')
    lines = f.readlines()
    f.close()
    
    is_or_not = False
    with open('INCAR') as myfile:
        if parameter in myfile.read():
            is_or_not = True
    
    if is_or_not:
        f = open('INCAR', 'w')
        for line in lines:
            if parameter in line:
                f.write('%s = %s\n' % (parameter, value))
            else:
                f.write(line)
        f.close()
    else:
        f = open('INCAR', 'a+')
        f.write('%s = %s\n' % (parameter, value))
        f.close()


def incar_delete(parameter):
    """Delete the parameter from INCAR file."""
    if not os.path.isfile('INCAR'):
        print("INCAR file not found.")
        return

    f = open('INCAR', 'r')
    lines = f.readlines()
    f.close()
    f = open('INCAR', 'w')
    for line in lines:
        if parameter not in line:
            f.write(line)
    f.close()


def set_ncore(ncore):
    """NCORE/parallelization cannot be used for frequency calculations."""
    if not os.path.isfile('INCAR'):
        print('No INCAR found. Can not add the NCORE parameter to it.')
    else:
        file_in = open('INCAR', 'r')
        lines = file_in.readlines()
        file_in.close()
        for line in lines:
            if 'IBRION' in line:
                value = line.rstrip().split('=')[1].strip()
                if value not in ['5', '6', '7', '8']:
                    incar_alter('NCORE', ncore)
                else:
                    incar_delete('NCORE')


def similar(a, b):
    """Calculate similarity ratio between two strings."""
    return SequenceMatcher(None, a, b).ratio()


# ============================================================================
# Utility functions
# ============================================================================

def get_available_tasks():
    """Return list of available task names."""
    return sorted(tasks_recorded)


def get_task_params(task_name):
    """Get parameters for a specific task."""
    task_name_lower = task_name.lower()
    for key, params in tasks_incar.items():
        if task_name_lower == key.split('_')[2].lower():
            return params
    return None


def get_standard_params():
    """Return the standard INCAR parameters."""
    return standard_incar.copy()
